
############################################
### CORE ROUINTES FOR COMMUNICATING
### WITH MG-RAST
############################################

############################################
### unexported globals that hold "state"
############################################

#.auth <- ""
#.server <- ""
# using global options kbase.auth and kbase.server for now

############################################
### check for servers and auth key upon
### package loading
###
### the mechanism to preserve an auth
### key is to assign it to a global symbol.
### the user then may ensure it is saved
### for the next session
###
### .auth is used and hidden, whereas 
### kbase.auth.key is exported and not used
############################################
### lists relevant servers

### hooks unused for now:
### .onLoad <- function (libname, pkgname) { }
### .onUnload <- function (libname) { }

.onAttach <- function (libname, pkgname) {
	APIAuth <<- options ("matRAuth")$matRAuth
	if (is.null (APIAuth)) {
		APIAuth <<- ""
		packageStartupMessage ( "matR: no auth key" )
		}
	else packageStartupMessage ("matR: using auth key: ", APIAuth )

	APIServer <<- options ("matRServer")$matRServer
	if (is.null (APIServer)) APIServer <<- APIServers$dev3
# if (is.null (APIServer)) APIServer <<- APIServers$prod
	packageStartupMessage ("matR: server: ", APIServer)

# .... test network
#	success <- TRUE
#	if (success) packageStartupMessage ("matR: server reached") 
#	else packageStartupMessage ("matR: server not reached")
	packageStartupMessage ("matR: network not checked")

#set print.default
#set download.file.method
	options (warn = 1)
	packageStartupMessage( "matR: this package sets global option(s): warn = 1")

	packageStartupMessage (paste (
		"\nThis code is under active development.",
		"Feedback, feature suggestions, and bug reports are welcome.",
		#"Test codes are in the installation directory.",
		#"Usage examples are included with the documentation,",
		"A few things to try:   demo(matR)   package?matR   ?AbundanceRetrieval   utils::example(orgMatrix)", 
		sep="\n"))
	}

.Last.lib <- function (libpath) { 
#options (kbase.server = NULL)
#options (kbase.auth = NULL)
	rm (APIAuth, APIServer)
	}

### the server can be viewed and set manually
.mGetServer <- function () { APIServer }
# getOption (kbase.server) }


# does not work
# .mSetServer <- function ( s ) { APIServer <<- s }
#options (kbase.server = s) }


### simple interface to get and set the auth key.  it is set automatically upon loading, if it exists
.mGetAuth <- function() { APIAuth }
#getOption (kbase.auth) }

# .mSetAuth <- function (key = NULL, save = FALSE) {
# if (is.null (key) ) {
#	message( "matR: Enter authorization key on a single line: " )
#	key <- readLines (n=1, ok=TRUE, warn=FALSE)
#}
#if (save) {
#	warning ("matR: authorization key set in global environment may be saved to .RData file")
#	APIAuth.key <<- key
#}
# options (kbase.auth = key)
#APIAuth <<- key
#}


############################################
### we export a routine for "raw" calls to
### the API as alternative when the high-level 
### routines break.  idea for this is to be
### unsophisticated but robust.  perhaps
### eventually to be implemented more carefully 
### with RCurl.  this is also the foundation
### for higher level calls
############################################
#
# implementation may need changing.
# the desired behavior is:
# if (server wants to send a file(s))
#	if (toFile == NULL)
#		if (server indicates a name(s))
#			save with that name(s)
#		else
#			save with name(s) generated by temp.file
#	else
#		save named as toFile
# else
#	if (toFile == NULL)
#		return text object
#	else
#		write to file named as toFile
#
# and,
# always return file name(s) if result is a file
#
.mCallRaw <- function (call, toFile = NULL) {
	if (!length (grep ("?", call, fixed = TRUE))) conj = "?"
	else conj = "&"
	urlStr <- paste (.mGetServer(), call, conj, "auth=", .mGetAuth(), sep = "")
	message ("matR: .mCallRaw: ", urlStr)
	if (!is.null (toFile)) {
		download.file (urlStr, toFile, quiet = TRUE)
		toFile
		}
	else readLines (urlStr, warn = FALSE)
	}

############################################
### these are routines intended for general use
############################################

### get a list of all resources of one type.  
### a convenience function for no-parameter calls
mListAll <- function (resource) {
	suppressPackageStartupMessages (require (RJSONIO))
	if ( !oneofmust (resource, "project", "sample", "library", "annotation", "metagenome")) return ()
	x <- fromJSON (.mCallRaw (resource), simplify = TRUE, asText = TRUE)
	x
#	invisible (switch (resource, 
#		project = as.vector (x$projects),
#		sample = as.vector (x$samples),
#		library = as.vector (x$librarys),
#		annotation = as.vector (x),
#		metagenome = as.vector (x$metagenomes)))			### return R-friendly object	
	}

# perform an md5 lookup in the specified annotation database
# ... it seems this is not yet implemented in the API
# ... so, this is untested ...
mAnnotationLookup <- function (md5, namespace) {
	suppressPackageStartupMessages (require (RJSONIO))
	md5 <- chomp (md5)
	namespace <- chomp (namespace)
	if (length (namespace) > 1) {
		warning ("matR: only one namespace may be specified")
		return ()
		}
	x <- character( length (md5))
	for (j in 1:length (md5))
		x [ j ] <- fromJSON (.mCallRaw ( paste ("annotation?md5=", md5 [ j ], sep = "")))
	x
	}

### search metagenomes in mgrast for specified criteria
### ... fix me ...
mSearchMetagenomes <- function (resource, attribute = NULL, value = NULL) {
	warning( "matR: unimplemented function" )
	suppressPackageStartupMessages (require (RJSONIO))
### ... .mCallRaw etc ...
	}

# specify a resource and get it back in an R-friendly form
# this routine handles API calls WHICH REQUIRE AN ID
# it is an interface, not a wrapper, meaning the defaults and
# interaction schema of the API are reconsidered
#
# returns object(s) if object(s) retrieved
# returns filename(s) if file(s) retrieved
# return filenames visibly and objects invisibly
#
# ... write to file (in first call, recursive call, or raw call?)
# ... also, when to notify of file writes?
# ... can an organism name or functional annotation contain a semicolon?? ...
# ... add prefixes such as "mgp" etc.
# ... consistent return value on failure
# ... checking of actual content of JSON object
#
# for anyone looking at this: a good bit of the craziness here
# is meant as a hedge against fluctuations in the API 
mGet <- function( 
	resource,				# single value
	ID,						# multiple value
	namespace = NULL,		# multiple
	annoType = NULL,		# single
	seqType = NULL,			# single
	org = NULL,				# multiple
	func = NULL,			# multiple
	md5 = NULL,				# multiple
	param = NULL,			# any string, will be passed directly to the call
	toFile = NULL ) {

	suppressPackageStartupMessages (require (RJSONIO))
# for "abundance" calls, there are naturally multiple 
# IDs in a single API call.  this function also allows
# multiple IDs for other resource calls, but handles them by 
# recursion, making one API call per ID.

# so first we check up on the ID parameter.
# it is natural to look at how output is requested
# (with toFile) at the same time

# we allow flexible specification of the ID parameter.
# a vector is natural to R scripting, while
# semicolon-separated is natural to interactive use
IDs <- chomp (ID)

# and we also accept semicolon-separated filenames
semiwarn (toFile)
toFile <- chomp (toFile)

if (length (IDs) > 1) {
	if ( oneof (resource, "project", "sample", "library", "metagenome")) {
		x = list ()
# for text-ish resources we allow either one filename
# per ID, or a single filename (meaning: append all to one)
		if (!is.null (toFile) && length (toFile) != 1 && length (toFile) != length (IDs)) {
			warning ("matR: call requires single filename or one filename per ID"); 
			return ()
			}
		deststr <- NULL
		for (j in 1:length (IDs)) {
			x [[j]] <- mGet (resource, IDs [j], namespace, annoType, seqType, org, func, md5, param)
			if (length (toFile) > 1) {
				sink (file = toFile [j]) ; print (x [[j]]) ; sink()
				deststr <- paste (" to ", toFile [j])
				}
			message ("matR: fetched ", resource, " ", IDs [j], deststr)
			}
		if (length (toFile) == 1) {
			sink (file = toFile) ; print (x) ; sink()
			message ("matR: wrote to ", toFile)
			}
		if (!is.null (toFile)) return (toFile)
		return (x)
		}
	if (oneof (resource, "sequenceSet", "reads")) {
# for resources received as files,
# we require one filename per ID,
# or else no filenames (meaning: use defaults)
		if (!is.null (toFile) && length (toFile) != length (IDs)) {
			warning ("matR: call requires one filename per ID");
			return ()
			}
# NB. we allow that a single call might return more than one file
# ... that is why the length of outFiles is unknown
# ... and we have to use horrible style here
		outFiles <- character(0)
		for (j in 1:length (IDs)) {
			ff <- mGet (resource, IDs [j], namespace, annoType, seqType, org, func, md5, param, toFile [j] )
			message ("matR: fetched ", resource, " ", IDs [j], " to ", ff)
			outFiles <- c (outFiles, ff)
			}
		return (outFiles)
		}
	if (resource != "abundance") {
		warning ("matR: multiple ID\'s not implemented for specified resource"); 
		return ()
		}
	}

# from here on we are in the case of single of no
# filename, and in the case of a single ID, except
# if resource is "abundance"

# code below is repeated unnecessarily when the function
# recurs, but we live with that inefficiency

# we require retrieval to disk of certain resources
if (oneof (resource, "sequenceSet", "reads") && is.null (toFile)) {
	message ("matR: using default filename for file resource")
	toFile <- paste (resource, ".", ID, sep = "")
}

# we now check up on parameters carefully, while
# constructing the API call

# make sure the resource type is valid
if ( !oneofmust (resource, "project", "sample", "library", "metagenome", "subset", "sequenceSet", "sequences",  "reads", "abundance")) return ()

# ... warn of functionality not yet implemented ...
if ( !oneofmusnt (resource, "sequenceSet", "reads")) return ()

# warn of parameters specified but not appropriate to the call
if ( !is.null( switch (resource,
		project = c (namespace, annoType, seqType, org, func, md5),
		sample = c (namespace, annoType, seqType, org, func, md5),
		library = c (namespace, annoType, seqType, org, func, md5),
		metagenome = c (namespace, annoType, seqType, org, func, md5),
		subset = c (seqType, md5),
		sequenceSet = c (namespace, annoType, seqType, org, func, md5),
		sequences = NULL,
		reads = c (namespace, annoType, seqType, org, func, md5),
		abundance = c (seqType, org, func, md5), NULL))) {
	warning ("matR: invalid parameter for specified resource")
	return ()
	}

# now make strings for other provided parameters
#	namespace --- multiple (subset, sequences), single (abundance)
#	annoType --- single (subset, sequences, abundance)
#	seqType --- single (sequences)
#	org --- multiple (subset, sequences)
#	func --- multiple (subset, sequences)
#	md5s --- multiple (sequences), single (for annotation; there called "md5")

namespace <- chomp (namespace)
# ... check here for valid values of namespace ...
if (resource == "abundance" && length (namespace) > 1) {
	warning ("matR: abundance must be taken against a single namespace")
	return ()
	}
nsStr <- if (is.null (namespace)) NULL
	else paste ("source", chomp (namespace), collapse = "&", sep = "=")

if ( length (annoType) > 1) {
	warning ("matR: only one annotation type may be specified")
	return ()
	}
annoTypeStr <- if (is.null (annoType)) NULL
				else if ( !oneofmust (annoType, "organism", "functional")) return()
				else paste ("type", annoType, sep = "=")

if ( length (seqType) > 1) {
	warning ("matR: only one sequence type may be specified")
	return ()
	}
seqTypeStr <- if (is.null (seqType)) NULL
	else if ( !oneofmust (seqType, "dna", "protein")) return ()
	else paste ("seq", seqType, sep = "=")

orgStr <- if (is.null (org)) NULL
	else paste ("organism", chomp (org), collapse = "&", sep = "=")
funcStr <- if (is.null (func)) NULL
	else paste ("function", chomp (func), collapse = "&", sep = "=")
md5Str <- if (is.null (md5)) NULL
	else paste ("md5s", chomp (md5), collapse = "&", sep = "=" )

callStr <- paste (nsStr, annoTypeStr, seqTypeStr, orgStr, funcStr, md5Str, sep = "")
resourceStr <- paste (switch (resource, abundance = "matrix", resource), "/", sep="")		# a tweak
IDstr <- paste (glom (IDs), "/", sep = "")
paramStr <- paste (param, "?", sep = "")				# a string passed directly

# the API call needs no post-processing in case of
# a file resource (and we return the filename as
# returned by .mCallRaw)
if (oneof (resource, "sequenceSet", "reads"))
	return (.mCallRaw (paste (resourceStr, IDstr, paramStr, callStr, sep = ""), toFile))
else
	x <- .mCallRaw (paste (resourceStr, IDstr, paramStr, callStr, sep = ""))

# otherwise, we process what we have received
notJSON <- FALSE
y <- try (fromJSON (x, simplify = TRUE, asText = TRUE), silent = TRUE)
if (is (y, "try-error")) { 
	message ("matR: received raw (not JSON)")
	notJSON <- TRUE
	}
else message ("matR: ", length (unlist (y)), " elements (before reduction)")

# x is used for the return value of this function
# y is used for the JSON object received
#
# rearrange and rename fields of text resources nicely
if (oneof (resource, "project", "sample", "library", "metagenome", "sequences") && !notJSON) {
	x <- simpleJSONReduction (y)
# ... this sometimes chokes when the retrieved object is incomplete ...
	switch (resource, 
		project = { names (x)[3] <- "kbase" },
		sample = { names (x)[2] <- "kbase" },
		library = { names (x)[2] <- "kbase" },
		metagenome = { names (x)[2] <- "kbase" })
	}
# process abundance matrix nicely from out of BIOM format
# ... the eventual plan is to implement an RBIOM class ...
if (resource == "abundance") {
	if (notJSON) {
		f <- tempfile ()
		writeLines (x, f)
		x <- data.matrix (read.table (f, header = TRUE, sep = "\t", quote = "", row.names = 1, check.names = FALSE))
		unlink (f)
		}
	else if (y$matrix_type == "sparse") {
# first we make a full matrix via the provided sparse matrix
# remembering that BIOM indices start at zero
		n <- length (y$data)
		spM <- matrix (unlist (y$data), nrow = n, ncol = 3, byrow = TRUE)
		M <- as.matrix (Matrix::sparseMatrix (i = 1 + spM [,1], j = 1 + spM [,2], x = spM [,3], dims = y$shape))
# extract the column names that we expect
		n <- y$shape [2]
		s <- character (n)
		for (j in 1:n)  s[j] <- (y$columns [[j]] ["id"])
		colnames (M) <- s
# what the row names should be is debatable
# ... perhaps I should check with others ...
# here, we collapse the taxonomy to a single string
		s <- character (n <- y$shape [1])
		for (j in 1:n)  s[j] <- paste (y$rows [[j]] $metadata$taxonomy, collapse = ";", sep = "")
		rownames (M) <- s
		x <- M
		}
	else warning ("matR: non-sparse JSON matrix received; not implemented")
}
# process subsets nicely into a data.frame
else if (resource == "subset" && !notJSON) {
	M <- cbind (data.frame (organism = names (y), row.names = NULL, stringsAsFactors = FALSE), count = unlist (lapply (y, length), use.names = FALSE))
	x <- data.frame ( organism = as.vector (with (M, rep (organism, count))), 
		md5 = unlist (lapply (y, names)), 
		count = unlist (y),
		row.names = NULL, stringsAsFactors = FALSE)
}
# ... process sequences nicely ...
else if (resource == "sequences" && !notJSON) {
}

# assign appropriate class to the return object
# ... do other resources need to be here? ...
x <- switch (resource,
	project = new ("mProjectMeta", ID = IDs, x),
	sample = new ("mSampleMeta", ID = IDs, x),
#	library = "mLibraryMeta",
	metagenome = new ("mMetagenomeMeta", ID = IDs, x),
	abundance = new ("mMatrix", d = x, m = list(0)),
	x)

# we return filenames visibly and objects invisibly
# ... this is definitely not how output should be done!
# ... probably there should be a "write" method defined
# ... for each class of returned object.  or, they should
# ... not even be objects, but just character vectors, simpler types
if (!is.null (toFile)) {
	sink (file = toFile) ; print (x) ; sink()
	message( "matR: wrote to ", toFile )
	toFile
	}
else x
}

# at one point I thought: "reads" retrieves multiple 
# files per ID (with different extensions), whereas
# "sequenceSet" retrieves only one, but I think that
# turns out to be false.

### if output is to disk, name output files 
### sensibly and according to the given parameter
#if (resource == "reads") {
#	if (toFile == NULL)
#		message ("matR: using default filenames for multiple file resource")
#	else
#		message ("matR: using specified filename as prefix for multiple file resource")
#	toFile = ....
#}

# ...may again need this kind of scanning of the parameter string ...
#
#	abundance = (if (1 == length (grep ("format/plain", paramStr, fixed = TRUE))) {
#		temp.file <- tempfile()
#		writeLines (x, temp.file)
#		y <- read.table (temp.file, header = TRUE, row.names = 1, sep = "\t", quote = "", comment.char = "")
#		unlink (temp.file)
#		y } else x),
#	x)

simpleJSONReduction <- function (x) {
	empty <- vapply(x, function (x) (length(x) == 0), TRUE)
	single <- vapply(x, function (x) (length(x) == 1), TRUE)
	y <- x[ !(single | empty)]
	y$more <- as.list (unlist (x [single], use.names = TRUE))
	y
	}

############################################
### hardcoded "parameters" of the package
############################################

### provides some valid API parameters for testing conveniently
.mTestParams <- function () {
	list (
		project = "92", 
		sample = "mgs3482", 
		library = "mgl3482.4",
		metagenome = c("4443360.3","4443361.3","4443362.3","4443363.3","4443364.3","4443365.3","4443366.3","4443367.3","4443368.3"),
		subset = "", 
		sequenceSet = "", 
		sequences = "", 
		annotation = "", 
		reads = "", 
		abundanceProfile = "mgm4440282.3", 
		abundance = "mgm4440282.3",
		md5 = "5c6cdf00b3b2509879f412d55582af1a",
		matrix = "",
		query = "")
}


############################################
### us!
############################################

dtb <- person()
kpk <- person()


