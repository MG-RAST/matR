
############################################
### CORE ROUTINES FOR COMMUNICATING
### WITH MG-RAST AND KBASE
###
### this is the API interface layer
############################################

############################################
### we export a routine for "raw" calls to
### the API as alternative when the high-level 
### routines break.  idea for this is to be
### unsophisticated but robust.  perhaps
### eventually to be implemented more carefully 
### with RCurl.  this is also the foundation
### for higher level calls
############################################
#
# implementation may need changing.
# the desired behavior is:
# if (server wants to send a file(s))
#	if (toFile == NULL)
#		if (server indicates a name(s))
#			save with that name(s)
#		else
#			save with name(s) generated by temp.file
#	else
#		save named as toFile
# else
#	if (toFile == NULL)
#		return text object
#	else
#		write to file named as toFile
#
# and,
# always return file name(s) if result is a file
#
.mCallRaw <- function (call, toFile = NULL) {
	if (!length (grep ("?", call, fixed = TRUE))) conj = "?"
	else conj = "&"
	urlStr <- paste (mConfig$server (), call, conj, "auth=", mConfig$getAuth (), sep = "")
# assign "lastURL" recovery variable here
	optMessage ("matR: reading ", urlStr)
	mConfig$lastURL (urlStr)
	if (!is.null (toFile)) {
		download.file (urlStr, toFile, quiet = TRUE)
		toFile
		}
	else readLines (urlStr, warn = FALSE)
	}

############################################
### these are routines intended for general use
############################################

### get a list of all resources of one type.  
### a convenience function for no-parameter calls
mListAll <- function (resource) {
	reqPack ("RJSONIO")
	if ( !oneofmust (resource, "project", "sample", "library", "annotation", "metagenome")) return ()
	x <- fromJSON (.mCallRaw (resource), simplify = TRUE, asText = TRUE)
	x
#	invisible (switch (resource, 
#		project = as.vector (x$projects),
#		sample = as.vector (x$samples),
#		library = as.vector (x$librarys),
#		annotation = as.vector (x),
#		metagenome = as.vector (x$metagenomes)))			### return R-friendly object	
	}

# perform an md5 lookup in the specified annotation database
# ... it seems this is not yet implemented in the API
# ... so, this is untested ...
mAnnotationLookup <- function (md5, namespace) {
	reqPack ("RJSONIO")
	md5 <- chomp (md5)
	namespace <- chomp (namespace)
	if (length (namespace) > 1) {
		warning ("matR: only one namespace may be specified")
		return ()
		}
	x <- character( length (md5))
	for (j in 1:length (md5))
		x [ j ] <- fromJSON (.mCallRaw ( paste ("annotation?md5=", md5 [ j ], sep = "")))
	x
	}

### search metagenomes in mgrast for specified criteria
### ... fix me ...
mSearchMetagenomes <- function (resource, attribute = NULL, value = NULL) {
	warning( "matR: unimplemented function" )
	reqPack ("RJSONIO")
### ... .mCallRaw etc ...
	}

# the purpose of mGet is to speak the language of the API
# and acts as a buffer against changes therein.
#
# specify a resource and get it back in an R-friendly form
# this routine handles API calls WHICH REQUIRE AN ID
# it is an interface, not a wrapper, meaning the defaults and
# interaction schema of the API are reconsidered
#
# returns object(s) if object(s) retrieved
# returns filename(s) if file(s) retrieved
# return filenames visibly and objects invisibly
#
# ... write to file (in first call, recursive call, or raw call?)
# ... also, when to notify of file writes?
# ... can an organism name or functional annotation contain a semicolon?? ...
# ... add prefixes such as "mgp" etc.
# ... consistent return value on failure
# ... checking of actual content of JSON object
#
# for anyone looking at this: a good bit of the craziness here
# is meant as a hedge against fluctuations in the API 
mGet <- function( 
	resource,				# single value
	ID,						# multiple value
	namespace = NULL,		# multiple
	annoType = NULL,		# single
	seqType = NULL,			# single
	org = NULL,				# multiple
	func = NULL,			# multiple
	md5 = NULL,				# multiple
	param = NULL,			# any string, will be passed directly to the call
	parse = TRUE,			# attempt parsing?  (of JSON or plain text)
	enClass = FALSE,			# returned classed objects?
	toFile = NULL ) {

# for "abundance" calls, there are naturally multiple 
# IDs in a single API call.  this function also allows
# multiple IDs for other resource calls, but handles them by 
# recursion, making one API call per ID.

# so first we check up on the ID parameter.
# it is natural to look at how output is requested
# (with toFile) at the same time

# we allow flexible specification of the ID parameter.
# a vector is natural to R scripting, while
# semicolon-separated is natural to interactive use
IDs <- chomp (ID)

# and we also accept semicolon-separated filenames
semiwarn (toFile)
toFile <- chomp (toFile)

if (length (IDs) > 1) {
	if ( oneof (resource, "project", "sample", "library", "metagenome")) {
		x <- list ()
# for text-ish resources we allow either one filename
# per ID, or a single filename (meaning: append all to one)
		if (!is.null (toFile) && length (toFile) != 1 && length (toFile) != length (IDs))
			stop ("matR: call requires single filename or one filename per ID"); 

		deststr <- NULL
		for (j in 1:length (IDs)) {
			x [[j]] <- mGet (resource, IDs [j], namespace, annoType, seqType, org, func, md5, param)
			if (length (toFile) > 1) {
				sink (file = toFile [j]) ; print (x [[j]]) ; sink()
				deststr <- paste (" to ", toFile [j])
				}
			optMessage ("matR: fetched ", resource, " ", IDs [j], deststr)
			}
		if (length (toFile) == 1) {
			sink (file = toFile) ; print (x) ; sink()
			optMessage ("matR: wrote to ", toFile)
			}
		if (!is.null (toFile)) return (toFile)
		return (x)
		}
	if (oneof (resource, "sequenceSet", "reads")) {
# for resources received as files,
# we require one filename per ID,
# or else no filenames (meaning: use defaults)
		if (!is.null (toFile) && length (toFile) != length (IDs))
			stop ("matR: call requires one filename per ID");
# NB. we allow that a single call might return more than one file
# ... that is why the length of outFiles is unknown
# ... and we have to use horrible style here
		outFiles <- character(0)
		for (j in 1:length (IDs)) {
			ff <- mGet (resource, IDs [j], namespace, annoType, seqType, org, func, md5, param, toFile [j] )
			optMessage ("matR: fetched ", resource, " ", IDs [j], " to ", ff)
			outFiles <- c (outFiles, ff)
			}
		return (outFiles)
		}
	if (resource != "abundance") stop ("matR: multiple ID\'s not implemented for specified resource")
	}

# from here on we are in the case of single or no
# filename, and (unless resource is "abundance") in 
# the case of single ID

# code below is repeated unnecessarily when the function
# recurs, but we live with that 

# we require retrieval to disk of certain resources
if (oneof (resource, "sequenceSet", "reads") && is.null (toFile)) {
	message ("matR: using default filename for file resource")
	toFile <- paste (resource, ".", ID, sep = "")
	}

# we now check up on parameters carefully, while
# constructing the API call

# make sure the resource type is valid
oneofmust (resource, "project", "sample", "library", "metagenome", "subset", "sequenceSet", "sequences",  "reads", "abundance")
# ... and the functionality is implemented ...
oneofmust (resource, "project", "sample", "metagenome", "abundance")
# oneofmusnt (resource, "sequenceSet", "reads")

# warn of parameters specified but not appropriate to the call
if ( !is.null( switch (resource,
		project = c (namespace, annoType, seqType, org, func, md5),
		sample = c (namespace, annoType, seqType, org, func, md5),
		library = c (namespace, annoType, seqType, org, func, md5),
		metagenome = c (namespace, annoType, seqType, org, func, md5),
		subset = c (seqType, md5),
		sequenceSet = c (namespace, annoType, seqType, org, func, md5),
		sequences = NULL,
		reads = c (namespace, annoType, seqType, org, func, md5),
		abundance = c (seqType, org, func, md5), NULL))) {
	warning ("matR: invalid parameter for specified resource")
	return ()
	}

# now make strings for other provided parameters
#	namespace --- multiple (subset, sequences), single (abundance)
#	annoType --- single (subset, sequences, abundance)
#	seqType --- single (sequences)
#	org --- multiple (subset, sequences)
#	func --- multiple (subset, sequences)
#	md5s --- multiple (sequences), single (for annotation; there called "md5")

namespace <- chomp (namespace)
# ... check here for valid values of namespace ...
if (resource == "abundance" && length (namespace) > 1) {
	warning ("matR: abundance must be taken against a single namespace")
	return ()
	}
nsStr <- if (is.null (namespace)) NULL
	else paste ("source", chomp (namespace), collapse = "&", sep = "=")

if ( length (annoType) > 1) {
	warning ("matR: only one annotation type may be specified")
	return ()
	}
annoTypeStr <- if (is.null (annoType)) NULL
				else if ( !oneofmust (annoType, "organism", "functional")) return()
				else paste ("type", annoType, sep = "=")

if ( length (seqType) > 1) {
	warning ("matR: only one sequence type may be specified")
	return ()
	}
seqTypeStr <- if (is.null (seqType)) NULL
	else if ( !oneofmust (seqType, "dna", "protein")) return ()
	else paste ("seq", seqType, sep = "=")

orgStr <- if (is.null (org)) NULL
	else paste ("organism", chomp (org), collapse = "&", sep = "=")
funcStr <- if (is.null (func)) NULL
	else paste ("function", chomp (func), collapse = "&", sep = "=")
md5Str <- if (is.null (md5)) NULL
	else paste ("md5s", chomp (md5), collapse = "&", sep = "=" )

callStr <- paste (nsStr, annoTypeStr, seqTypeStr, orgStr, funcStr, md5Str, sep = "")
resourceStr <- paste (switch (resource, abundance = "matrix", resource), "/", sep="")		# a tweak
IDstr <- paste (glom (IDs), "/", sep = "")
paramStr <- paste (param, "?", sep = "")				# a string passed directly

# the API call needs no post-processing in case of
# a file resource (and we return the filename as
# returned by .mCallRaw)
if (oneof (resource, "sequenceSet", "reads"))
	return (.mCallRaw (paste (resourceStr, IDstr, paramStr, callStr, sep = ""), toFile))
else
	x <- .mCallRaw (paste (resourceStr, IDstr, paramStr, callStr, sep = ""))

# otherwise, we process what we have received
if (parse) {
	reqPack ("RJSONIO")
	JSON <- FALSE
	if (isValidJSON (x, asText = TRUE)) {
# metadata elements are left as recursive lists (simplify = FALSE)
		x <- fromJSON (x, asText = TRUE,
				simplify = !oneof (resource, "project", "library", "sample", "metagenome"))
		optMessage ("matR: ", length (unlist (x)), " elements after JSON parsing")
		JSON <- TRUE
		}
	else optMessage ("matR: did not receive JSON")

# ... the eventual plan is to implement an RBIOM class ...
# process abundance matrix nicely ...
	if (resource == "abundance") {
#  ... from out of plain text format
		if (! JSON) {
			f <- tempfile ()
			writeLines (x, f)
# even where the matrix is passed is text format, we handle it as a Matrix
			x <- Matrix (data.matrix (read.table (f, header = TRUE, sep = "\t", quote = "", comment.char = "", row.names = 1, check.names = FALSE)))
			unlink (f)
			}
# or from sparse BIOM format
		else if (x$matrix_type == "sparse") {
# first we make a full matrix via the provided sparse matrix
# remembering that BIOM indices start at zero
			n <- length (x$data)
			spM <- matrix (unlist (x$data), nrow = n, ncol = 3, byrow = TRUE)
			M <- as.matrix (Matrix::sparseMatrix (i = 1 + spM [,1], j = 1 + spM [,2], x = spM [,3], dims = x$shape))
# extract the column names that we expect
			n <- x$shape [2]
			s <- character (n)
			for (j in 1:n)  s[j] <- (x$columns [[j]] ["id"])
			colnames (M) <- s
# what the row names should be is debatable
# ... perhaps I should check with others ...
# here, we collapse the taxonomy to a single string
			s <- character (n <- x$shape [1])
			for (j in 1:n)  s[j] <- paste (x$rows [[j]] $metadata$taxonomy, collapse = ";", sep = "")
			rownames (M) <- s
			x <- M
			}
		else warning ("matR: non-sparse matrix received in JSON; not implemented")
		}
# ... process subsets nicely into a data.frame ...
	else if (resource == "subset" && JSON) {
		M <- cbind (data.frame (organism = names (x), row.names = NULL, stringsAsFactors = FALSE), count = unlist (lapply (x, length), use.names = FALSE))
		x <- data.frame ( organism = as.vector (with (M, rep (organism, count))), 
			md5 = unlist (lapply (x, names)), 
			count = unlist (x),
			row.names = NULL, stringsAsFactors = FALSE)
		}
# ... process sequences nicely ...
	else if (resource == "sequences" && JSON) {
		}

# this section should assign the appropriate class to the return object...
	if (enClass) {
# ...BUT instead we are not allowing this option for now
# ...whether or not mGet should enClass things is still a grey-area design issue
		stop ("matR: unimplemented function")
		x <- switch (resource,
			project = new ("mProjectMeta", ID = IDs, listify (x)),
			sample = new ("mSampleMeta", ID = IDs, listify (x)),
#			library = ...
			metagenome = new ("mMetagenomeMeta", ID = IDs, listify (x)),
			abundance = new ("mmatrix", data = x, meta = list ()),
			x)
		}
	}

# ... this is definitely not how output to file should be done!
# ... probably there should be a "write" method defined
# ... for each class of returned object.  Or, they should
# ... not even be objects, but just character vectors, simpler types
if (!is.null (toFile)) {
	sink (file = toFile) ; print (x) ; sink()
	optMessage( "matR: wrote to ", toFile )
	toFile
	}
else x
}

# at one point I thought: "reads" retrieves multiple 
# files per ID (with different extensions), whereas
# "sequenceSet" retrieves only one, but I think that
# turns out to be false.

### if output is to disk, name output files 
### sensibly and according to the given parameter
#if (resource == "reads") {
#	if (toFile == NULL)
#		message ("matR: using default filenames for multiple file resource")
#	else
#		message ("matR: using specified filename as prefix for multiple file resource")
#	toFile = ....
#}

simpleJSONReduction <- function (x) {
	empty <- vapply(x, function (x) (length(x) == 0), TRUE)
	single <- vapply(x, function (x) (length(x) == 1), TRUE)
	y <- x[ !(single | empty)]
	y$more <- as.list (unlist (x [single], use.names = TRUE))
	y
	}
