
############################################
### CORE ROUTINES FOR COMMUNICATING
### WITH MG-RAST AND KBASE
###
### this is the API interface layer
############################################

############################################
### we export a routine for "raw" calls to
### the API as alternative when the high-level 
### routines break.  idea for this is to be
### unsophisticated but robust.  perhaps
### eventually to be implemented more carefully 
### with RCurl.  this is also the foundation
### for higher level calls
############################################
#
# implementation may need changing.
# the desired behavior is:
# if (server wants to send a file(s))
#	if (toFile == NULL)
#		if (server indicates a name(s))
#			save with that name(s)
#		else
#			save with name(s) generated by temp.file
#	else
#		save named as toFile
# else
#	if (toFile == NULL)
#		return text object
#	else
#		write to file named as toFile
#
# and,
# always return file name(s) if result is a file
#

callRaw <- function (call, file = NULL) {
	if (!length (grep ("?", call, fixed = TRUE))) conj = "?"
	else conj = "&"
	urlStr <- paste (mconfig$server (), call, conj, "auth=", mconfig$getAuth (), sep = "")
	optMessage ("requesting ", urlStr)
	mconfig$lastURL (urlStr)
	if (!is.null (file)) {
		e <- try (download.file (urlStr, file, quiet = TRUE))
		if (inherits (e, "try-error")) e
		else file
		}
	else try (readLines (urlStr, warn = FALSE))
	}

############################################
### Now these are routines intended for general use
############################################

### get a list of all resources of one type.  
### a convenience function for no-parameter calls
mListAllIds <- function (resource = c ("project", "sample", "library", "annotation", "metagenome")) {
	reqPack ("RJSONIO")
	fromJSON (callRaw (match.arg (resource)), simplify = TRUE, asText = TRUE)
	}

# perform an md5 lookup in the specified annotation database
# ... it seems this is not yet implemented in the API
# ... so, this is untested ...
mAnnotationLookup <- function (md5, namespace) {
	reqPack ("RJSONIO")
	md5 <- chomp (md5)
	namespace <- chomp (namespace)
	if (length (namespace) > 1) {
		warning ("only one namespace may be specified")
		return ()
		}
	x <- character( length (md5))
	for (j in 1:length (md5))
		x [ j ] <- fromJSON (callRaw ( paste ("annotation?md5=", md5 [ j ], sep = "")))
	x
	}

### search metagenomes in mgrast for specified criteria
### ... fix me ...
mSearchMetagenomes <- function (resource, attribute = NULL, value = NULL) {
	warning ("unimplemented function")
	reqPack ("RJSONIO")
### ... callRaw etc ...
	}

# mGet will implement special handling of API resources, one-by-one.
# but in the meantime, any resource can be called through a general interface,
# named parameters specified in ... or as a list in "with"
# additionally, parameter "x" represents the assumption that an ID of some kind is usually required
mGet <- function (resource = "matrix", x, with = NULL, ..., parse = TRUE, enClass = FALSE, file = NULL) { 
	args <- append (with, list (...))

# here we call the old API for metadata only
	if (resource %in% c ("project", "sample", "library", "metagenome")) {
		s <- mconfig$server()
		mconfig$server (mconfig$servers()$test)
		y <- try (oldmGet (resource, ID = x, namespace = args$namespace, annoType = args$annoType, seqType = args$seqType, org = args$org, 
											 func = args$func, md5 = args$md5, param = args$param, parse = parse, enClass = enClass, toFile = file))
		mconfig$server (s)
	}

	else {
		callStr <- resource

# per-resource preprocessors
		switch (resource,
						"matrix" =
{
	callStr <- paste (callStr, "/", args$name, sep = "")
	args$name <- NULL
})

# generic request procedure
		callStr <- paste (callStr, "?",
											paste ("id", x, sep = "=", collapse = "&"), "&",
											paste (names (args), unname (args), sep = "=", collapse = "&"),
											sep = "")
		y <- callRaw (callStr, file)
		if (inherits (y, "try-error")) warning ("resource request unsuccessful")
		if (!parse) return (y)
		reqPack ("RJSONIO")
		valid <- try (isValidJSON (y, asText = TRUE))
		if (!is.logical (valid) || !valid) warning ("cannot parse non-JSON object")
		else y <- fromJSON (y, asText = TRUE, simplify = TRUE)
		optMessage (length (unlist (y)), " elements after JSON parsing")

# per-resource postprocessors
		switch (resource,
						matrix = 
{
	if (length (setdiff (c ("data", "rows", "columns"), names (y))) != 0) warning ("bad format in received resource")
	m <- matrix (unlist (y$data), ncol = 3, byrow = TRUE)
	m <- as.matrix (Matrix::sparseMatrix (i = 1 + m [,1], j = 1 + m [,2], x = m [,3]))
	rownames (m) <- sapply (y$rows, `[[`, i = "id")
	colnames (m) <- sapply (y$columns, `[[`, i = "id")

# need to know if this is even supposed to be generally valid
# it doesn't always work

#	rh <- lapply (y$rows, function (x) unlist (x [[c ("metadata", "ontology")]]))
#	hlen <- max (sapply (rh, length))
#	attr (m, "rowhier") <- t (sapply (rh, `length<-`, hlen))
	y <- m
})

	}
	y
}


# the purpose of mGet is to speak the language of the API
# and acts as a buffer against changes therein.
#
# specify a resource and get it back in an R-friendly form
# this routine handles API calls WHICH REQUIRE AN ID
# it is an interface, not a wrapper, meaning the defaults and
# interaction schema of the API are reconsidered
#
# returns object(s) if object(s) retrieved
# returns filename(s) if file(s) retrieved
# return filenames visibly and objects invisibly
#
# ... write to file (in first call, recursive call, or raw call?)
# ... also, when to notify of file writes?
# ... can an organism name or functional annotation contain a semicolon?? ...
# ... add prefixes such as "mgp" etc.
# ... consistent return value on failure
# ... checking of actual content of JSON object
#
# for anyone looking at this: a good bit of the craziness here
# is meant as a hedge against fluctuations in the API 
oldmGet <- function( 
	resource = c ("project", "sample", "library", "metagenome", "abundance"),      # single value
	ID,			      			# multiple value
	namespace = NULL,		# multiple
	annoType = NULL,		# single
	seqType = NULL,			# single
	org = NULL,				# multiple
	func = NULL,			# multiple
	md5 = NULL,				# multiple
	param = NULL,			# any string, will be passed directly to the call
	parse = TRUE,			# attempt parsing?  (of JSON or plain text)
	enClass = FALSE,			# returned classed objects?
	toFile = NULL ) {

# for "abundance" calls, there are naturally multiple 
# IDs in a single API call.  this function also allows
# multiple IDs for other resource calls, but handles them by 
# recursion, making one API call per ID.

# so first we check up on the ID parameter.
# it is natural to look at how output is requested
# (with toFile) at the same time

# we allow flexible specification of the ID parameter.
# a vector is natural to R scripting, while
# semicolon-separated is natural to interactive use
IDs <- scrubIds (ID)

# and we also accept semicolon-separated filenames
semiwarn (toFile)
toFile <- chomp (toFile)

resource <- match.arg (resource)

if (length (IDs) > 1) {
	if ( oneof (resource, "project", "sample", "library", "metagenome")) {
		x <- list ()
# for text-ish resources we allow either one filename
# per ID, or a single filename (meaning: append all to one)
		if (!is.null (toFile) && length (toFile) != 1 && length (toFile) != length (IDs))
			stop ("call requires single filename or one filename per ID"); 

		deststr <- NULL
		for (j in 1:length (IDs)) {
			x [[j]] <- oldmGet (resource, IDs [j], namespace, annoType, seqType, org, func, md5, param)
			if (length (toFile) > 1) {
				sink (file = toFile [j]) ; print (x [[j]]) ; sink()
				deststr <- paste (" to ", toFile [j])
				}
			optMessage ("fetched ", resource, " ", IDs [j], deststr)
			}
		if (length (toFile) == 1) {
			sink (file = toFile) ; print (x) ; sink()
			optMessage ("wrote to ", toFile)
			}
		if (!is.null (toFile)) return (toFile)
		return (x)
		}
	if (oneof (resource, "sequenceSet", "reads")) {
# for resources received as files,
# we require one filename per ID,
# or else no filenames (meaning: use defaults)
		if (!is.null (toFile) && length (toFile) != length (IDs))
			stop ("call requires one filename per ID");
# NB. we allow that a single call might return more than one file
# ... that is why the length of outFiles is unknown
# ... and we have to use horrible style here
		outFiles <- character(0)
		for (j in 1:length (IDs)) {
			ff <- oldmGet (resource, IDs [j], namespace, annoType, seqType, org, func, md5, param, toFile [j] )
			optMessage ("fetched ", resource, " ", IDs [j], " to ", ff)
			outFiles <- c (outFiles, ff)
			}
		return (outFiles)
		}
	if (resource != "abundance") stop ("multiple ID\'s not implemented for specified resource")
	}

# from here on we are in the case of single or no
# filename, and (unless resource is "abundance") in 
# the case of single ID

# code below is repeated unnecessarily when the function
# recurs, but we live with that 

# we require retrieval to disk of certain resources
if (oneof (resource, "sequenceSet", "reads") && is.null (toFile)) {
	message ("using default filename for file resource")
	toFile <- paste (resource, ".", ID, sep = "")
	}

# we now check up on parameters carefully, while
# constructing the API call

# warn of parameters specified but not appropriate to the call
if ( !is.null( switch (resource,
		project = c (namespace, annoType, seqType, org, func, md5),
		sample = c (namespace, annoType, seqType, org, func, md5),
		library = c (namespace, annoType, seqType, org, func, md5),
		metagenome = c (namespace, annoType, seqType, org, func, md5),
		subset = c (seqType, md5),
		sequenceSet = c (namespace, annoType, seqType, org, func, md5),
		sequences = NULL,
		reads = c (namespace, annoType, seqType, org, func, md5),
		abundance = c (seqType, org, func, md5), NULL))) {
	warning ("invalid parameter for specified resource")
	return ()
	}

# now make strings for other provided parameters
#	namespace --- multiple (subset, sequences), single (abundance)
#	annoType --- single (subset, sequences, abundance)
#	seqType --- single (sequences)
#	org --- multiple (subset, sequences)
#	func --- multiple (subset, sequences)
#	md5s --- multiple (sequences), single (for annotation; there called "md5")

namespace <- chomp (namespace)
# ... check here for valid values of namespace ...
if (resource == "abundance" && length (namespace) > 1) {
	warning ("abundance must be taken against a single namespace")
	return ()
	}
nsStr <- if (is.null (namespace)) NULL
	else paste ("source", chomp (namespace), collapse = "&", sep = "=")

if ( length (annoType) > 1) {
	warning ("only one annotation type may be specified")
	return ()
	}
annoTypeStr <- if (is.null (annoType)) NULL
				else if ( !oneofmust (annoType, "organism", "functional")) return()
				else paste ("type", annoType, sep = "=")

if ( length (seqType) > 1) {
	warning ("only one sequence type may be specified")
	return ()
	}
seqTypeStr <- if (is.null (seqType)) NULL
	else if ( !oneofmust (seqType, "dna", "protein")) return ()
	else paste ("seq", seqType, sep = "=")

orgStr <- if (is.null (org)) NULL
	else paste ("organism", chomp (org), collapse = "&", sep = "=")
funcStr <- if (is.null (func)) NULL
	else paste ("function", chomp (func), collapse = "&", sep = "=")
md5Str <- if (is.null (md5)) NULL
	else paste ("md5s", chomp (md5), collapse = "&", sep = "=" )

callStr <- paste (nsStr, annoTypeStr, seqTypeStr, orgStr, funcStr, md5Str, sep = "")
resourceStr <- paste (switch (resource, abundance = "matrix", resource), "/", sep="")		# a tweak
IDstr <- paste (glom (IDs), "/", sep = "")
paramStr <- paste (param, "?", sep = "")				# a string passed directly

# the API call needs no post-processing in case of
# a file resource (and we return the filename as
# returned by callRaw)
if (oneof (resource, "sequenceSet", "reads"))
	return (callRaw (paste (resourceStr, IDstr, paramStr, callStr, sep = ""), toFile))
else
	x <- callRaw (paste (resourceStr, IDstr, paramStr, callStr, sep = ""))

# otherwise, we process what we have received
if (parse) {
	reqPack ("RJSONIO")
	JSON <- FALSE
	if (isValidJSON (x, asText = TRUE)) {
# metadata elements are left as recursive lists (simplify = FALSE)
		x <- fromJSON (x, asText = TRUE,
				simplify = !oneof (resource, "project", "library", "sample", "metagenome"))
		optMessage (length (unlist (x)), " elements after JSON parsing")
		JSON <- TRUE
		}
	else optMessage ("did not receive JSON")

# ... the eventual plan is to implement an RBIOM class ...
# process abundance matrix nicely ...
	if (resource == "abundance") {
#  ... from out of plain text format into "Matrix" class
		if (! JSON) {
			f <- tempfile ()
			writeLines (x, f)
			x <- Matrix::Matrix (data.matrix (read.table (f, header = TRUE, sep = "\t", quote = "", comment.char = "", row.names = 1, check.names = FALSE)))
			unlink (f)
			}
# ... or from sparse BIOM format
# remembering that BIOM indices start at zero
		else if (x$matrix_type == "sparse") {
# first we make a full matrix via the provided sparse matrix
			n <- length (x$data)
			spM <- matrix (unlist (x$data), nrow = n, ncol = 3, byrow = TRUE)
			M <- Matrix::sparseMatrix (i = 1 + spM [,1], j = 1 + spM [,2], x = spM [,3], dims = x$shape)
# extract the column names that we expect
			s <- character (n <- x$shape [2])
			for (j in 1:n)  s[j] <- x$columns [[j]] ["id"]
			colnames (M) <- s
# what the row names should be is debatable... perhaps I should check with others
# here, we collapse the taxonomy to a single string
			s <- character (n <- x$shape [1])
			for (j in 1:n)  s[j] <- paste (x$rows [[j]] $metadata$taxonomy, collapse = ";", sep = "")
			rownames (M) <- s
			x <- M
			}
		else warning ("non-sparse matrix received in JSON; not implemented")
		}
# ... process subsets nicely into a data.frame ...
	else if (resource == "subset" && JSON) {
		M <- cbind (data.frame (organism = names (x), row.names = NULL, stringsAsFactors = FALSE), count = unlist (lapply (x, length), use.names = FALSE))
		x <- data.frame ( organism = as.vector (with (M, rep (organism, count))), 
			md5 = unlist (lapply (x, names)), 
			count = unlist (x),
			row.names = NULL, stringsAsFactors = FALSE)
		}
# ... process sequences nicely ...
	else if (resource == "sequences" && JSON) {
		}

# this section should assign the appropriate class to the return object...
	if (enClass) {
# ...BUT instead we are not allowing this option for now
# ...whether or not mGet should enClass things is still a grey-area design issue
		stop ("unimplemented function")
		x <- switch (resource,
			project = new ("mProjectMeta", ID = IDs, listify (x)),
			sample = new ("mSampleMeta", ID = IDs, listify (x)),
#			library = ...
			metagenome = new ("mMetagenomeMeta", ID = IDs, listify (x)),
			abundance = new ("mmatrix", data = x, meta = list ()),
			x)
		}
	}

# ... this is definitely not how output to file should be done!
# ... probably there should be a "write" method defined
# ... for each class of returned object.  Or, they should
# ... not even be objects, but just character vectors, simpler types
if (!is.null (toFile)) {
	sink (file = toFile) ; print (x) ; sink()
	optMessage( "wrote to ", toFile )
	toFile
	}
else x
}

# at one point I thought: "reads" retrieves multiple 
# files per ID (with different extensions), whereas
# "sequenceSet" retrieves only one, but I think that
# turns out to be false.

### if output is to disk, name output files 
### sensibly and according to the given parameter
#if (resource == "reads") {
#	if (toFile == NULL)
#		message ("using default filenames for multiple file resource")
#	else
#		message ("using specified filename as prefix for multiple file resource")
#	toFile = ....
#}

simpleJSONReduction <- function (x) {
	empty <- vapply(x, function (x) (length(x) == 0), TRUE)
	single <- vapply(x, function (x) (length(x) == 1), TRUE)
	y <- x[ !(single | empty)]
	y$more <- as.list (unlist (x [single], use.names = TRUE))
	y
	}
